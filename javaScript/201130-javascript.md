# 15. let, const와 블록 레벨 스코프

# var 키워드 문제점

- 변수 중복 선언 허용
- 함수 레벨 스코프 (전역 스코프)
- 변수 호이스팅

# let 키워드

- 변수 중복 선언 금지
- 블록 레벨 스코프 (지역 변수)

![Untitled](https://user-images.githubusercontent.com/72958778/100558757-fd6a2b00-32f2-11eb-994c-2215b5c4a7cf.png)


- 변수 호이스팅 발생 안하는 것처럼 동작

![Untitled 1](https://user-images.githubusercontent.com/72958778/100558763-0824c000-32f3-11eb-9883-ad07db0da39c.png)


(let 키워드로 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행)

![Untitled 2](https://user-images.githubusercontent.com/72958778/100558774-107cfb00-32f3-11eb-993c-ac864659198d.png)

일시적 사각지대(Temporal Dead Zone; TDZ)

# const 키워드

- 상수(constant)를 선언하기 위해 사용하지만, 반드시 상수만을 위해 사용하지 않음
- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화
- 재할당 금지
- 상태유지와 가독성, 유지보수의 편의성에 좋음
- const 키워드로 선언된 변수에 객체를 할당한 경우, 객체 값을 변경할 수 있음

# var, let, const

- ES6를 사용한다면 var 키워드는 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다.
- 변수 선언에는 기본적으로 const를 사용하고 재할당이 필요할 경우 let을 한정해서 사용하는 것을 권장

# 16. 프로퍼티 어트리뷰트

# 내부슬롯과 메서드

Ecmascript 사양에 등장하는 [[...]] 이중 대괄호는 대부분 내부슬롯과 내부메서드이다

내부슬롯과 내부메서드는 자바스크립트 엔진 내부 로직이므로 원칙적으로 자바스크립트는 내부슬롯과 내부메서드에 직접적으로 호출이나 접근 방법을 제공하지 않는다.

일부에서는 간접적으로 제공.

자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

프로퍼티 상태

- 프로퍼티의 값
- 값의 갱신 여부
- 열거 가능 여부
- 재정의 가능 여부

프로퍼티 어트리뷰트 - 엔전이 관리하는 내부 상태값인 내부슬롯

- [[Value]]
- [[Writable]]
- [[Enumerable]]
- [[Configurable]]

프로퍼티 어트리뷰트에 직접 접근할 수 없지만 Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인할 수는 있다.

Object.getOwnPropertyDescriptor 메서드는 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터(PropertyDescriptor) 객체를 반환